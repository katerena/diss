\section{Software Production in the Sciences}

\kt{softare production in the sciences: 3-5 themes that i cover, inc collaboration, visualization, openness}

Software production in a scientific context can be studied from at least two directions: coding as one among many things that scientists are doing, and coding in science as distinct from coding in other contexts. The latter comes with an explicit or implicit comparison of how coding in science can benefit from adopting practices from other types of coding. I follow this approach through a variety of research areas, most commonly computer-supported cooperative work (CSCW) and software engineering. \kt{transition}

Paine and Lee in a study of a radio astronomy collaboration argue that the data products and software pipelines are co-produced \cite{paine2014producing}. Their research is positioned in the scholarship on knowledge infrastructures, data infrastructures, and scientific workflows in CSCW, and they argue that ``design decisions producing data and software products
in scientific research are fundamentally intertwined since they
are developed simultaneously with decisions made for one
product directly impacting the other. CSCW and eScience
scholars do not typically explicitly claim that these products
are fully separable, however, we also rarely discuss them as
intertwined.'' The timbre of this work is weighed toward stressing the \textit{legitimacy} and \textit{importance} of code work among scientists who ``acknowledge that this work is necessary and a fact of their day-to-day lives, yet still do not entirely consider such work to truly be the `scientific' work in and of itself.'' Paine and Lee stress that ``iterative system development is key for answering their scientific questions and the development of the necessary research infrastructures'' and therefore that ``such `non-scientific' work has a deep and lasting impact on the group's scientific outcomes.'' % The issue is that "it isn't science is derogatory somewhow

\subsection{Uniqueness of Scientific Code}

In this subsection, I synthesize how existing literature claims code produced in the scientific context to be unique, either relative to other forms of scientific work (e.g, wet lab work) or other coding contexts (e.g., software development in the industry).

\kt{SOFTWARE IS UNIQUE AMAZING} For example, Howison and Herbsleb note that ````Unlike other technologies supporting science, software can be copied and distributed at essentially no cost, potentially opening the door to unprecedented levels of sharing and collaborative innovation. Yet we do not have a clear picture of how software development for science fits into the day-to-day practice of science, or how well the methods and incentives of its production facilitate realization of this potential'' \cite{howison2011scientific} - this articulation of software practice as offering unprecedented potential is a crucial part of the vision of software in the perfect world as not only solving problems but fundamentally challenging the daily reality of work.


What, other than a sense of a lack of recognition of effort, is distinct about software work in science relative to other contexts? Sletholt et al write: ``in contrast to the development of, say, administrative or business  enterprise software, the writers of scientific software cannot  determine what the correct output of an application should be in  the traditional sense. Also, the software may evolve through the  combined effort of a number of scientists over the course of many  years, continuously adding new functionality to the system \cite{sletholt2011literature}.'' This strand of research characterizes software production in the sciences as qualitatively different from other contexts because of a more uncertain concept of the end result or outcome  \cite{heaton2015claims}; requirements are volatile \cite{sletholt2011literature}; subject to continuous maintenance  \cite{sletholt2011literature}, following through with which is primarily socially-motivated (in a philosophical at least as much as a transactional sense) \cite{trainer2015personal}; not subject to formal design process \cite{heaton2015claims,paine2014producing} but nevertheless adapting various programming best-practices, most notably elements of the agile process \cite{heaton2015claims,sletholt2011literature}. In some cases, particularly in numerical approximation code, scientific code can exist without appropriate maintenance, relative to the high-performance computing hardware on which it is meant to be run \cite{palyart2011improving}. Heaton and Carver provide a systematic overview of studies of software engineering practices in scientific code (again, numerical approximation / modeling in particular), concluding also on the general lack of maintainability or readability of code \cite{heaton2015claims}. \kt{code is unique}

\subsection{``Best Practices''}

Code work in the scientific context is therefore both crucial to recently-emerging methods, and uncomfortably ad-hoc. The term ``best practices'' refers to industry-wide, shared ideas about the best way to do things. These  often stress putting code (and data) online for others to access \cite{stodden2013best}, even if it cannot run but at least as a documentation of scientific activity \cite{mislan2016elevating}. Wilson et al offer 8 concrete directions, including things like ``plan for mistakes (turn bugs into test cases)'' which connect a minor expected roadblock or problem (a bug) into the opportunity for a ``best practice'' act (testing) \cite{wilson2014best}. The suggested practices from Baxter et al are a bit more high-level: ``1) design the project up-front; 2) document programs and key processes; 3) apply quality control; 4) use data standards where possible; and 5) incorporate project management'' \cite{baxter2006scientific}.

In addition to the software-related strategies and practices above, additional practices concern making data more effectively available through ``deliberate documentation'' and persistent quality access \cite{baker2008enabling}. The list of best practices is in constant flux, as noted by Sletholt et al who conduct a review of agile practices reported in scientific publications, and who characterize scientific practice as distinct from other contexts in that it is relatively more ad-hoc and grounded in experience \cite{sletholt2011literature}.



%In his ethnography of the self-identified ``community'' in open source software, Leach claims that ``computer programmers working within this genre share a \textbf{moral imagination} of a particular kind that ... can be understood through reference to its emergence in close relation with specific methods of technical production,'' identifying a ``reciprocal dynamic ... in which \textbf{better computer software is seen as dependent on particular social practices and ideologies}, while certain social practices and ideologies are given particular salience by their success in fostering the production of `good' code'' \cite[emphases added]{leach2009freedom}. In explaining F/LOSS (Free / Libre Open Source Software), Leach identifies the technical distinction (source is "released" along with the binary, allowing modification to F/LOSS programs but not proprietary programs) as well as the claimed distinction of quality by virtue of peer-review, community modification, and so on; this, F/LOSS ``software projects form self-declared communities that see themselves as collectively providing a better alternative to the way in which software is commercially produced and distributed as a proprietary enterprise.'' The reflexive F/LOSS community identifies among its values \emph{freedom}, and a notion of contributing to the common good: ``the moral values of community and progress are embedded in descriptive language in and around f/loss and how in turn this builds on a sense of the moral agency of f/loss software as a system of production itself.'' Beyond this, Leach evokes and explains the notion of the \emph{aesthetics of code:} ``the moral discourse is wrapped up in an aesthetics of code. Judgements made about code are seen as aesthetic judgements which nevertheless are seen to have an objective basis in reality (moral judgements and truth claims overlap)'' and further that ``this aesthetics of code generates a conception of future potential that in turn makes the activity of writing code a version of exploring and opening up physical and mental frontiers.'' The language of what is 'best' in code is dependent upon the programming language in question, and in ``debates, logical arguments are interspersed with appeals to aesthetic criteria and to ethical/political and economic values.''

\subsection{Incentives and Aesthetics}

In this subsection, I pull together work that highlights how little is practically understood about the tension between the practical and the beautiful in scientific software work. Speaking to code in ecology in particular, Mislan et al note that ``even code that is rough and difficult to run on other systems (owing to software dependencies and differences in computing platforms) still provides valuable information as part of detailed documentation of the analyses'' \cite{mislan2016elevating}. The authors suggest some venues for publishing code, presenting different options side-by-side in a table ``Comparison of Common Resources,'' and urge journals to make code citation more prominent to address this issue. Trainer et al introduce the concept of ``extra work,'' referring to all the maintenance and support work that is not formally accommodated in scientific practice but which is practically necessary to make that code viable  \cite{trainer2015personal}. In their typology of motivations for doing said ``extra work,'' every category includes a social connection, an actual interpersonal request, or some other opportunity for recognition of effort or a sense that someone is actually using something.  Enke et al, writing about biodiversity \textit{data} sharing, divide all measures to encourage more sharing into ``stick'' and ``carrot'' measures, with many more specific implications on the basis of more than 700 survey responses \cite{enke2012user}, but adding to the chorus of needing recognition for doing thankless and crucial heavy lifting.

In his reflection on the design and implementation of the Software Carpentry curriculum for well over a decade, Wilson writes that computational scientists do not have the publishing incentives to prioritize code quality, so the course does not attempt to ```sell' quality directly... Instead, it starts from the fact that the only way to improve productivity is to improve quality'' \cite{wilson2013software}. The claim of the ``fact'' is an illustration of the relationship between moral and material aspects of code work:

\litquote{leach2009freedom}{A central component of the F/LOSS  ethos is that working openly and sharing the source code of software enables improvements to evolve more effectively, and that as a whole ``better'' software is produced. The concept of `better software' (a material judgement), which arises from `better' processes of production (a moral judgement) conceals another complex series of understandings and judgements generated by familiarity with and proximity to the workings of the machine (computer) itself ... the beauty of code comes to be an aim in itself in this overlap of practical and moral truth.}

Leach reports on an ethnographic study of free/libre and open-source software (F/LOSS), going on to point out how his informants would often claims that the ``messiness'' of proprietary software is the primary reason it remains inaccessible, and that its producers ``would dare not to open source their code because [of shame over] how its functionality was achieved.'' The informants quoted in my dissertation often expressed hesitance to open up source code on account of its messiness, which is distinct from the concern over attribution as articulated by Enke \cite{enke2012user}. ``I am not a real programmer'' and ``it works, but it's not the most elegant way to do things'' were common asides among the participants of this study when describing their own work. The craftsmanship of code, as elevated by the F/LOSS ethos, trickles into the self-reflective scientific code discourse and touches on ``open science'' and related notions. For example, Software Carpentry has engaged in the F/LOSS community and value system since its inception in the 90s \cite{wilson2013software}. The interpretations of ``best practices'' for scientific coding invariably stress sharing in general and sometimes open source in particular \cite{mislan2016elevating,stodden2013best}. The mechanics are distinct between these notions, but they all embody a common value of sharing, which is simultaneously powerful enough to warrant a great deal of discussion and non-specific enough for that discussion to mostly focus on critiquing shortcomings.

Howison and Herbsleb identify several different \textit{software production systems} articulated in terms of the social and institutional contexts and in incentives \cite{howison2011scientific}. One these software production systems is \textit{parallel software practice}, which is similar to what Paine and Lee focus on in \cite{paine2014producing}, and which Howison and Herbsleb do not critique. On the other hand, the authors suggest that a ``dual science and software practice is a somewhat questionable proposition for working scientists'' because aside from creation effort, the maintenance effort is unreasonable and inescapable. This maintenance effort is the ``extra work'' that Trainer et al identify as motivate primarily by social means \cite{trainer2015personal}. For example, direct interpersonal exchange over email or with a past colleague can help prioritise an endless list of possible features with unclear ramifications for scientific users. The discussion of incentives and motivations concerns itself with the \textit{material}, while the discussion of increasing sharing or code ``messiness'' concerns itself with the \textit{moral}. Leach notes that the material goodness of better software is achieved by the moral goodness of better practice. The assumption behind critiquing and problematizing incentive structures reverses the relationship, making the moral goodness of open-science-related concepts accessible through the material goodness of rewarding effective code work practices.




%He continues: as in manufacturing and medicine, investments in quality repay themselves several times over because mistakes are more expensive to fix than to prevent.'' In Kelly's articulation of the subject of herrisk-averse programmer'' she distinguishes this code - which MUST work - from the experimental kind which is undertaken by many scientists [kelly]



Like scientific code work, F/LOSS distinguishes itself from the ``typical'' industrial software setting \cite{leach2009freedom}. In a study of software ownership (``a general term used to describe whether one person has responsibility for a software component, or if there is no one clearly responsible developer'') at Microsoft, Bird et al demonstrate and explore the claim that ``when there is no clear point of contact and the contributions to a software component are spread across many developers, there is an increased chance of communication breakdowns, misaligned goals, inconsistent interfaces and semantics, all leading to lower quality'' \cite{bird2011don}. They note that ``New methods ... profess collective code ownership but there has been little empirical evidence or backing of this data on reasonably mature/complex or large systems'' - though not speaking of F/LOSS as a whole, they note one such paradigm of software practice which shares some practical components with the F/LOSS ethos described above and makes similar quality claims. In their synthesis of literature on the challenges of software, especially communication, Bird et al draw a link between expertise and ownership: those who are responsible for the code have an expertise that is not merely helpful but necessary for future development on a particular component \cite{bird2011don}. On a similar note, Kelly writes that ``the scientist is an integral part of the software system and cannot be excluded from its consideration'' \cite{kelly2015scientific}.


The software engineering studies of scientific software work reviewed in this chapter (e.g., \cite{heaton2015claims}) distinguish scientific software production as unique from other coding contexts. Kelly points out that scientists identify their coding practices largely by non-adherence to a particular software production methodology \cite{kelly2015scientific}. This ``amethodical'' narrative is presented in contrast to the methodical one by Truex et al \cite{truex2000amethodical}. The methodical, privileged approach to code work holds that software systems development is more controlled and rational than it is in lived practice of industry software engineering. Truex et al create an alternate narrative that ``occurs in completely unique and idiosyncratic forms''. In the lived reality of coding, neither exists in its elementary state, but the amethodical narrative is marginalized in reflection about software engineering practices. Building on this work, Philip et al study amethodical remixing, or the use of copy and paste and snippets \cite{philip2012software}. Though these practices are not included in textbook, privileged accounts of development, they are nevertheless present. Implications offer design of tools that support more realistic everyday scenarios of re-mixing, which blend the dialectic methodical and amethodical narratives. Concern over 

%The authors develop measurements for ownership (e.g., "how much of the development activity for a component comes from one developer") and test their hypothesis on components from Windows 7 and Windows Vista releases, showing, among some other nuanced claims, that "he number of minor contributors has a strong positive relationship with both pre- and post-release failures even when controlling for metrics such as size, churn, and complexity." In describing generalizability of their work, the authors comment: "the results of empirical software engineering studies do not always generalize to settings where a different process is used. The process that is used may dictate the effect of other factors on software quality as well. ...  Microsoft employs strong ownership practices and our results are much more likely to hold in other industrial settings where similar policies are in place. Examining the effect of ownership in contexts where ownership is not stressed as highly, such as in many open source software (OSS) projects, is an area of continued study."

%Although F/LOSS distinguishes itself from the hierarchical industrial software setting, and vice versa, Leach comments also points out a surprisingly-pronounced hierarchy, with authority ``often enforced in displays of aggressive argument and belittling of others.'' Complementing its community-centric philosophy, F/LOSS is associated with a sense of individual craftsmanship, where ``the craft in question is satisfying only when it is seen in terms of a model of knowledge that locates agency and activity within the technologist, who thereby himself pushes back the frontier of knowledge.'' In this sense, ``morality and ethics are inseparable from the objects which the community produces. Politics, and an imagined future, are pursued through the construction and development of software, of objects, which themselves are to carry the burden of, and are believed to instantiate, an ethical and moral vision. Politics in this case can be engaged though writing software in a particular manner.'' \cite{leach2009freedom}

%In prior work with colleagues, I studied the expression of affect in scientific collaborations. With Scott et al, we developed a taxonomy for affect expression appropriate for text-based chat in a scientific collaboration \cite{scott2012adapting}. With Brooks et al, we worked on a machine learning approach to help annotate a large corpus of chat logs with these labels \cite{brooks2013statistical}. Our focus was on how emotions were expressed and mediated through technology in a collaborative, creative scientific setting over time (in that case, over a 5-year astronomy collaboration). The taxonomy of affect we had developed built on a definition of affect as ``a feeling or emotion as distinct from cognition'' \cite{russ1993affect}, specific to text-based chat as a communication medium that has features of other asynchronous communication media (e.g., the persistence of email) as well as features of synchronous communication (real-time, immediate responses, and the corresponding performance of emotion through punctuation, emoticons, and so on).

%This paper also explains why a particular type of scientist, one who works in a highly risk-averse application domain, does not conform to the common characterization of all scientists as “end-user programmers”. We offer observations of how this type of scientist develops trustworthy software. We observe that these scientists work outside the ubiquitous method-based software development paradigms, using instead a knowledge acquisition-based approach to software development. We also observe that the scientist is an integral part of the software system and cannot be excluded from its consideration. We suggest that use of the knowledge acquisition software development model requires research into how to support acquisition of knowledge while developing software, how to satisfy oversight in regulated application domains, and how to successfully manage a scientific group using this model. \cite{kelly2015scientific} 
% "define scientific software as application software that includes a large component of knowledge from the scientific application domain and is used to increase the knowledge of science for the purpose of solving real-world problems. We use the word “scientific” to include engineering applications."
% The term “scientific software” has been used for a wide variety of software types that do not share the same quality requirements or the same management priorities. Software written to become a commodity product, for example, is managed to meet delivery dates and budget constraints. Software written to verify the safety of a radiation procedure, has to be correct, to the exclusion of all else. We also exclude from our definition, software whose primary purpose is to control equipment.
% To clarify, we further characterize scientific software with the following: (a) a scientific domain specialist is necessarily involved in the pro- cess of developing the software; (b) the user of this software has some minimum knowledge of the associated scientific domain, to allow correct interpretation of the output data; (c) the user is the recipient of all output from the software, meaning the software’s purpose is not to control equipment; (d) the software’s primary purpose is to provide data for under- standing specific real world problems, meaning that the scientists we study do not develop generalized tools and libraries to support computational computing; (e) the overriding software quality is correctness – or more accu- rately, trustworthiness – and if trustworthiness fails, then all other software qualities are irrelevant.
%\cite{sletholt2011literature}

%%"But how well do current scientific software development processes match the practices found in agile development methods, and what are the effects of using agile practices in such processes?" "Both projects with intentionally agile practices and projects with a certain  degree of agile elements are taken into consideration." The authors compare projects in terms of using 35 agile practices which they ideantify. It's Agile + XP. And then they did a search based lit review, excluding, including based on the title, work that did not hold the software development at its focus. the searh terms included claims of agile and so on, and ultimately narrow down to a list of papers that explicitly address issues of integrating software engineering practices, like test-driven development, into scientific software development. \jinna{probably want to redo or delete this para}

%Though the uniqueness of scientific programming has been stressed, it cannot be seen without ackowledging programming itself as a varied practice with a great deal of variation. Even Sletholt et al acknowledge, regarding that the list of agile practices, against which scientific programming practices were compared, that such lists will remain in a constant state of flux" \cite{sletholt2011literature}. %trueex

%

%"Climate scientists build large, complex simulations with little or no software engineering training—and don't readily adopt the latest software engineering tools and techniques. This ethnographic study of climate scientists shows that their culture and practices share many features of agile and open source projects, but with highly customized software validation and verification techniques. Climate scientists build large, complex simulations with little or no software engineering training—and don't readily adopt the latest software engineering tools and techniques. An ethnographic study of climate scientists at the Hadley Centre for Climate Prediction and Research found that their culture and practices share many features of agile and open source projects. Specifically, they rely on self-organization of the teams, use informal communication channels extensively, and have developers who are also users and domain experts. They also have highly customized software verification and validation techniques that are tightly integrated into their scientific research. These observations suggest that domain-independent software development process models are unlikely to be useful for this type of scientific software development." \cite{easterbrook2009engineering}

%"Perhaps the notable testing achievements present here were caused by other factors, such as the level of  correctness required in the domain of climate change. Also, the  development process had some discrepancies in relation to a  proper agile process model, making it questionable whether  testing activities indeed were executed in an agile manner."\cite{sletholt2011literature}


% AND NOW, LEARNING
%"Climate scientists build large, complex simulations with little or no software engineering training—and don't readily adopt the latest software engineering tools and techniques. This ethnographic study of climate scientists shows that their culture and practices share many features of agile and open source projects, but with highly customized software validation and verification techniques. Climate scientists build large, complex simulations with little or no software engineering training—and don't readily adopt the latest software engineering tools and techniques. An ethnographic study of climate scientists at the Hadley Centre for Climate Prediction and Research found that their culture and practices share many features of agile and open source projects. Specifically, they rely on self-organization of the teams, use informal communication channels extensively, and have developers who are also users and domain experts. They also have highly customized software verification and validation techniques that are tightly integrated into their scientific research. These observations suggest that domain-independent software development process models are unlikely to be useful for this type of scientific software development." \cite{easterbrook2009engineering}


It is possible to argue that oceanography is an especially difficult case, as there is little standardization in method that would allow for the development of data infrastructures \cite{steinhardt2015anticipation}. On the basis of an ethnographic study of a large oceanography data infrastructure collaboration, Steinhardt and Jackson introduce the notions of ``anticipation work,'' which includes ``the mundane, local, and sometimes highly personal accommodations to the future that always accompany the more formalized and/or speculative dimensions.'' One of the examples of these ``highly personal accommodations to the future'' was the intention to learn new skills in anticipation of the next career move after the infrastructure project had wrapped up.

\tk Looking via interviews at the perspective of computer scientists engaged at middle-ware development, Lee et al \cite{lee2012sociotechnical} "examines how technologists develop and sustain middleware applciations over time by leveraging expertise and partnering with different research domains in order to achieve log-ter m infrastructural goals. activities to "sustain their software development research agenda well beyond the lifetime of project  Lee et alhave also emphasized the intensional personal networks as key - the human infrastructures that sustain cyberinfrastructure projects \cite{lee2006human}.

\kt{summarize greg wilson's reflective writings.}

\tk Howison and Herbsleb ask three questions of the software they study (via published manuscripts): ``1. What software is involved in this scientific field? 2. Who created or maintains this software? 3. What incentives drive that creation or maintenance work?'' \cite{howison2011scientific}. In this subsection, I answer these questions about the various software components in the groups studied. \kt{Finish PARA} INCENTIVES