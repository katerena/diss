\section{Software Production in the Sciences}

%\cite{hannay2009scientists}
%\cite{ko2006linguistic}

Software production in a scientific context can be studied from (at least) two directions: coding as one among many things that scientists are doing, and coding in science as distinct from coding in other contexts. The latter comes with an explicit or implicit follow-up on ways in which coding in science can benefit from adopting practices from other types of coding. I follow this outline through a variety of research areas (including computer-supported cooperative work, CSCW, and software engineering, SEng).

%CODE AS SOMETHING SCIENTISTS ARE DOING

Paine and Lee in a study of a radio astronomy collaboration argue that the data products and software pipelines are co-produced \cite{paine2014producing}. Their research is positioned in the scholarship on knowledge infrastructures, data infrastructures, and scientific workflows in CSCW, commenting in the manuscript that: ``The design decisions producing data and software products
in scientific research are fundamentally intertwined since they
are developed simultaneously with decisions made for one
product directly impacting the other. CSCW and eScience
scholars do not typically explicitly claim that these products
are fully separable, however, we also rarely discuss them as
intertwined.'' The timbre of this work is weighed toward stressing the \textit{legitimacy} and \textit{importance} of code work among scientists who ``acknowledge that this work is necessary and a fact of their day-to-day lives, yet still do not entirely consider such work to truly be the `scientific' work in and of itself.'' Paine and Lee stress, in their concluding statements, that ``iterative system development is key for answering their scientific questions and the development of the necessary research infrastructures'' and therefore that ``such `non-scientific' work has a deep and lasting impact on the group's scientific outcomes.'' % The issue is that "it isn't science is derogatory somewhow

Speaking to code in ecology in particular, Mislan et al. note, in a manuscript titled \textit{Elevating the status of code in
ecology}: ``even code that is rough and difficult to run on other systems (owing to software dependencies and differences in computing platforms) still provides valuable information as part of detailed documentation of the analyses'' \cite{mislan2016elevating}. The authors suggest some venues for publishing code, presenting different options side-by-side in a table ``Comparison of Common Resources,'' and urge journals to make code citation more prominent to address this issue. Trainer et al. introduce the concept of ``extra work,'' referring to all the maintenance and support work that is not formally accommodated in scientific practice but which is practically necessary \cite{trainer2015personal}. In their typology of motivations for doing said ``extra work,'' every category includes a social connection, an actual interpersonal request, or some other opportunity for recognition of effort or a sense that someone is actually using something.  Enke et al., writing about biodiversity \textit{data} sharing, divide all measures to encourage more sharing into ``stick'' and ``carrot'' measures, with many more specific implications on the basis of more than 700 survey responses \cite{enke2012user}, but adding to the chorus of needing recognition for doing, essentially, thankless and crucial heavy lifting.

What, other than a sense of a lack of recognition of effort, is distinct about software work in science relative to other contexts? Sletholt et al. write: ``in contrast to the development of, say, administrative or business  enterprise software, the writers of scientific software cannot  determine what the correct output of an application should be in  the traditional sense. Also, the software may evolve through the  combined effort of a number of scientists over the course of many  years, continuously adding new functionality to the system \cite{sletholt2011literature}.'' This strand of research characterizes software production in the sciences as qualitatively different from other because of a more uncertain concept of the end result or outcome  \cite{heaton2015claims}; requirements are volatile \cite{sletholt2011literature}; subject to continuous maintenance  \cite{sletholt2011literature}, following through with which is primarily socially-motivated (in a philosophical at least as much as a transactional sense) \cite{trainer2015personal}; not subject to formal design process \cite{heaton2015claims,paine2014producing} but nevertheless adapting various programming best-practices, most notably elements of the agile process \cite{heaton2015claims,sletholt2011literature}. In some cases, particularly in numerical approximation code, scientific code can exist without appropriate maintenance, relative to the high-performance computing hardware on which it is meant to be run \cite{palyart2011improving}. Heaton and Carver provide a systematic overview of studies of software engineering practices in scientific code (again, numerical approximation / modeling in particular), concluding also on the general lack of maintainability or readability of code \cite{heaton2015claims}.

Code work in the scientific context is therefore both crucial to recently-emerging methods, and uncomfortably ad-hoc. The term ``best practices'' refers to industry-wide, shared ideas about the best way to do things. These  often stress putting code (and data) online for others to access \cite{stodden2013best}, even if it cannot run but at least as a documentation of scientific activity \cite{mislan2016elevating}. Wilson et al. offer 8 concrete directions, including things like ``plan for mistakes (turn bugs into test cases)'' which connect a minor expected roadblock or problem (a bug) into the opportunity for a ``best practice'' act (testing) \cite{wilson2014best}. The suggested practices from Baxter et al. are a bit more high-level: ``1) design the project up-front; 2) document programs and key processes; 3) apply quality control; 4) use data standards where possible; and 5) incorporate project management'' \cite{baxter2006scientific}.

In addition to the software-related strategies and practices above, Ocean Informatics as described previously also suggests short-term as well as long-term information management strategies, including ``deliberate documentation'' and persistent quality access \cite{baker2008enabling}. Nevertheless, the list of best practices is in constant flux, as noted by Sletholt et al. who conduct a review of agile practices reported in scientific publications, and who characterize scientific practice as distinct from other contexts in that it is relatively more ad-hoc and grounded in experience \cite{sletholt2011literature}.



%In his ethnography of the self-identified ``community'' in open source software, Leach claims that ``computer programmers working within this genre share a \textbf{moral imagination} of a particular kind that ... can be understood through reference to its emergence in close relation with specific methods of technical production,'' identifying a ``reciprocal dynamic ... in which \textbf{better computer software is seen as dependent on particular social practices and ideologies}, while certain social practices and ideologies are given particular salience by their success in fostering the production of `good' code'' \cite[emphases added]{leach2009freedom}. In explaining F/LOSS (Free / Libre Open Source Software), Leach identifies the technical distinction (source is "released" along with the binary, allowing modification to F/LOSS programs but not proprietary programs) as well as the claimed distinction of quality by virtue of peer-review, community modification, and so on; this, F/LOSS ``software projects form self-declared communities that see themselves as collectively providing a better alternative to the way in which software is commercially produced and distributed as a proprietary enterprise.'' The reflexive F/LOSS community identifies among its values \emph{freedom}, and a notion of contributing to the common good: ``the moral values of community and progress are embedded in descriptive language in and around f/loss and how in turn this builds on a sense of the moral agency of f/loss software as a system of production itself.'' Beyond this, Leach evokes and explains the notion of the \emph{aesthetics of code:} ``the moral discourse is wrapped up in an aesthetics of code. Judgements made about code are seen as aesthetic judgements which nevertheless are seen to have an objective basis in reality (moral judgements and truth claims overlap)'' and further that ``this aesthetics of code generates a conception of future potential that in turn makes the activity of writing code a version of exploring and opening up physical and mental frontiers.'' The language of what is 'best' in code is dependent upon the programming language in question, and in ``debates, logical arguments are interspersed with appeals to aesthetic criteria and to ethical/political and economic values.''

On the basis of an ethnography study of free/libre and open-source software (F/LOSS), Leach describes a relationship between the notions of ``better code'' can combine \emph{material} and \emph{moral} judgments:

\litquote{leach2009freedom}{A central component of the F/LOSS  ethos is that working openly and sharing the source code of software enables improvements to evolve more effectively, and that as a whole ``better'' software is produced. The concept of `better software' (a material judgement), which arises from `better' processes of production (a moral judgement) conceals another complex series of understandings and judgements generated by familiarity with and proximity to the workings of the machine (computer) itself ... the beauty of code comes to be an aim in itself in this overlap of practical and moral truth. Often informants [of an ethnographic study of f/loss contributors] claimed that some proprietary software projects have not yet opened up their source code because of its messiness; that is, proprietary software producers would not dare to open source their code because they were ashamed of how its functionality has been achieved}

The informants quoted in my dissertation often expressed hesitance to open up source code on account of its messiness, which is distinct from the concern over attribution as articulated by Enke \cite{enke2012user}. The asides I had already mentioned as ubiquitous in my fieldwork - ``I am not a real programmer,'' in addition to ``it works, but it's not the most elegant way to do things.'' The craftsmanship of code, as elevated by the F/LOSS ethos, trickles into the self-reflective scientific code discourse through the concept of ``Open Science'' (and other related notions), and through institutions like Software Carpentry events, which had started in the late 90s under the auspices of the Mozilla foundation, which is engaged in the F/LOSS community and value system.

Like scientific code work, F/LOSS distinguishes itself from the ``typical'' industrial software setting \cite{leach2009freedom}. In a study of software ownership (``a general term used to describe whether one person has responsibility for a software component, or if there is no one clearly responsible developer'') at Microsoft, Bird et al. demonstrate and explore the claim that ``when there is no clear point of contact and the contributions to a software component are spread across many developers, there is an increased chance of communication breakdowns, misaligned goals, inconsistent interfaces and semantics, all leading to lower quality'' \cite{bird2011don}. They note that ``New methods ... profess collective code ownership but there has been little empirical evidence or backing of this data on reasonably mature/complex or large systems'' - though not speaking of F/LOSS as a whole, they note one such paradigm of software practice which shares some practical components with the F/LOSS ethos described above and makes similar quality claims. In their synthesis of literature on the challenges of software, especially communication, Bird et al. draw a link between expertise and ownership: those who are responsible for the code have an expertise that is not merely helpful but necessary for future development on a particular component \cite{bird2011don}. On a similar note, Kelly writes that ``the scientist is an integral part of the software system and cannot be excluded from its consideration'' \cite{kelly2015scientific}.

%The authors develop measurements for ownership (e.g., "how much of the development activity for a component comes from one developer") and test their hypothesis on components from Windows 7 and Windows Vista releases, showing, among some other nuanced claims, that "he number of minor contributors has a strong positive relationship with both pre- and post-release failures even when controlling for metrics such as size, churn, and complexity." In describing generalizability of their work, the authors comment: "the results of empirical software engineering studies do not always generalize to settings where a different process is used. The process that is used may dictate the effect of other factors on software quality as well. ...  Microsoft employs strong ownership practices and our results are much more likely to hold in other industrial settings where similar policies are in place. Examining the effect of ownership in contexts where ownership is not stressed as highly, such as in many open source software (OSS) projects, is an area of continued study."

%Although F/LOSS distinguishes itself from the hierarchical industrial software setting, and vice versa, Leach comments also points out a surprisingly-pronounced hierarchy, with authority ``often enforced in displays of aggressive argument and belittling of others.'' Complementing its community-centric philosophy, F/LOSS is associated with a sense of individual craftsmanship, where ``the craft in question is satisfying only when it is seen in terms of a model of knowledge that locates agency and activity within the technologist, who thereby himself pushes back the frontier of knowledge.'' In this sense, ``morality and ethics are inseparable from the objects which the community produces. Politics, and an imagined future, are pursued through the construction and development of software, of objects, which themselves are to carry the burden of, and are believed to instantiate, an ethical and moral vision. Politics in this case can be engaged though writing software in a particular manner.'' \cite{leach2009freedom}

%In prior work with colleagues, I studied the expression of affect in scientific collaborations. With Scott et al, we developed a taxonomy for affect expression appropriate for text-based chat in a scientific collaboration \cite{scott2012adapting}. With Brooks et al, we worked on a machine learning approach to help annotate a large corpus of chat logs with these labels \cite{brooks2013statistical}. Our focus was on how emotions were expressed and mediated through technology in a collaborative, creative scientific setting over time (in that case, over a 5-year astronomy collaboration). The taxonomy of affect we had developed built on a definition of affect as ``a feeling or emotion as distinct from cognition'' \cite{russ1993affect}, specific to text-based chat as a communication medium that has features of other asynchronous communication media (e.g., the persistence of email) as well as features of synchronous communication (real-time, immediate responses, and the corresponding performance of emotion through punctuation, emoticons, and so on).

%This paper also explains why a particular type of scientist, one who works in a highly risk-averse application domain, does not conform to the common characterization of all scientists as “end-user programmers”. We offer observations of how this type of scientist develops trustworthy software. We observe that these scientists work outside the ubiquitous method-based software development paradigms, using instead a knowledge acquisition-based approach to software development. We also observe that the scientist is an integral part of the software system and cannot be excluded from its consideration. We suggest that use of the knowledge acquisition software development model requires research into how to support acquisition of knowledge while developing software, how to satisfy oversight in regulated application domains, and how to successfully manage a scientific group using this model. \cite{kelly2015scientific} 
% Kelly uses the "amethodical" language to label the way that scientists themselves concieve of their programming work: Scientific software development has been characterized as enduser programming (Segal, 2004), considered a candidate for Agile iterative development (e.g., Ackroyd et al., 2008), and has been regulated with waterfall-style software quality development standards (Canadian Standards Association). Scientists themselves characterize their development approach as “a-methodical” (Truex et al., 2000).
% "define scientific software as application software that includes a large component of knowledge from the scientific application domain and is used to increase the knowledge of science for the purpose of solving real-world problems. We use the word “scientific” to include engineering applications."
% The term “scientific software” has been used for a wide variety of software types that do not share the same quality requirements or the same management priorities. Software written to become a commodity product, for example, is managed to meet delivery dates and budget constraints. Software written to verify the safety of a radiation procedure, has to be correct, to the exclusion of all else. We also exclude from our definition, software whose primary purpose is to control equipment.
% To clarify, we further characterize scientific software with the following: (a) a scientific domain specialist is necessarily involved in the pro- cess of developing the software; (b) the user of this software has some minimum knowledge of the associated scientific domain, to allow correct interpretation of the output data; (c) the user is the recipient of all output from the software, meaning the software’s purpose is not to control equipment; (d) the software’s primary purpose is to provide data for under- standing specific real world problems, meaning that the scientists we study do not develop generalized tools and libraries to support computational computing; (e) the overriding software quality is correctness – or more accu- rately, trustworthiness – and if trustworthiness fails, then all other software qualities are irrelevant.
%\cite{sletholt2011literature}

%%"But how well do current scientific software development processes match the practices found in agile development methods, and what are the effects of using agile practices in such processes?" "Both projects with intentionally agile practices and projects with a certain  degree of agile elements are taken into consideration." The authors compare projects in terms of using 35 agile practices which they ideantify. It's Agile + XP. And then they did a search based lit review, excluding, including based on the title, work that did not hold the software development at its focus. the searh terms included claims of agile and so on, and ultimately narrow down to a list of papers that explicitly address issues of integrating software engineering practices, like test-driven development, into scientific software development. \jinna{probably want to redo or delete this para}

%Though the uniqueness of scientific programming has been stressed, it cannot be seen without ackowledging programming itself as a varied practice with a great deal of variation. Even Sletholt et al. acknowledge, regarding that the list of agile practices, against which scientific programming practices were compared, that such lists will remain in a constant state of flux" \cite{sletholt2011literature}. %trueex

%

%"Climate scientists build large, complex simulations with little or no software engineering training—and don't readily adopt the latest software engineering tools and techniques. This ethnographic study of climate scientists shows that their culture and practices share many features of agile and open source projects, but with highly customized software validation and verification techniques. Climate scientists build large, complex simulations with little or no software engineering training—and don't readily adopt the latest software engineering tools and techniques. An ethnographic study of climate scientists at the Hadley Centre for Climate Prediction and Research found that their culture and practices share many features of agile and open source projects. Specifically, they rely on self-organization of the teams, use informal communication channels extensively, and have developers who are also users and domain experts. They also have highly customized software verification and validation techniques that are tightly integrated into their scientific research. These observations suggest that domain-independent software development process models are unlikely to be useful for this type of scientific software development." \cite{easterbrook2009engineering}

%"Perhaps the notable testing achievements present here were caused by other factors, such as the level of  correctness required in the domain of climate change. Also, the  development process had some discrepancies in relation to a  proper agile process model, making it questionable whether  testing activities indeed were executed in an agile manner."\cite{sletholt2011literature}


% AND NOW, LEARNING
%"Climate scientists build large, complex simulations with little or no software engineering training—and don't readily adopt the latest software engineering tools and techniques. This ethnographic study of climate scientists shows that their culture and practices share many features of agile and open source projects, but with highly customized software validation and verification techniques. Climate scientists build large, complex simulations with little or no software engineering training—and don't readily adopt the latest software engineering tools and techniques. An ethnographic study of climate scientists at the Hadley Centre for Climate Prediction and Research found that their culture and practices share many features of agile and open source projects. Specifically, they rely on self-organization of the teams, use informal communication channels extensively, and have developers who are also users and domain experts. They also have highly customized software verification and validation techniques that are tightly integrated into their scientific research. These observations suggest that domain-independent software development process models are unlikely to be useful for this type of scientific software development." \cite{easterbrook2009engineering}


It is possible to argue that oceanography is an especially difficult case, as there is little standardization in method that would allow for the development of data infrastructures \cite{steinhardt2015anticipation}. On the basis of an ethnographic study of a large oceanography data infrastructure collaboration, Steinhardt and Jackson introduce the notions of ``anticipation work,'' which includes ``the mundane, local, and sometimes highly personal accommodations to the future that always accompany the more formalized and/or speculative dimensions.'' One of the examples of these ``highly personal accommodations to the future'' was the intention to learn new skills in anticipation of the next career move after the infrastructure project had wrapped up.